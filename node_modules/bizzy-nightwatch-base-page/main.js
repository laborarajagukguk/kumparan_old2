/*
* set and access set_url
*/
var setURL = function(baseURL) {
  console.log('========================================');
  console.log('|| Accessing ' + baseURL + ' ||');
  console.log('========================================');
  return baseURL;
};

/*
* maximize window screen
*/
var maxWindow = function(page) {
  return page.resizeWindow(1920, 1080);
};

/*
* click element wait for present and visible
*/
var clickElement = function(page, elementSelector) {
  waitElementVisible(page, elementSelector)
  page.click(elementSelector);
};

/*
* click element without wait
*/
var clickElementWithoutWait = function(page, elementSelector) {
  page.click(elementSelector);
};

/*
* wait until element is present
*/
var waitElementPresent = function(page, elementSelector) {
  page.waitForElementPresent(elementSelector, 30000);
};

/*
* wait until element is visible
*/
var waitElementVisible = function(page, elementSelector) {
  waitElementPresent(page, elementSelector);
  page.waitForElementVisible(elementSelector, 30000);
};

/*
* set value to element
*/
var setValueElement =  function(page, elementSelector, value) {
  waitElementVisible(page, elementSelector);
  page.clearValue(elementSelector, function () {
    page.click(elementSelector, function() {
      page.setValue(elementSelector, value);
    })
  });
};

/*
* set value to element then press ENTER
*/
var setValueElementThenEnter =  function(page, elementSelector, value, browser) {
  waitElementVisible(page, elementSelector);
  page.clearValue(elementSelector, function(){
    page.click(elementSelector, function() {
      page.setValue(elementSelector, [value,browser.Keys.ENTER]);
    })
  });
};

/*
* get text from element
*/
var getStringText = function(page, elementSelector, expectedText) {
  waitElementVisible(page, elementSelector);
  return page.getText(elementSelector, function(result) {
    return result.value;
  });
};

/*
* check if the given element contains the specific text
*/
var assertContainsText = function(page, elementSelector, expectedText) {
  waitElementVisible(page, elementSelector);
  return page.assert.containsText(elementSelector,expectedText);
};

/*
* check if the given element equals the specific text
*/
var expectEqualsTextFromElement = function(page,elementSelector, expectedText) {
  waitElementVisible(page, elementSelector);
  return page.expect.element(elementSelector).text.to.equal(expectedText);
};

/*
* check if the given element equals the specific value
*/
var expectEqualsValueFromElement = function(page,elementSelector, expectedValue){
  waitElementVisible(page, elementSelector);
  return page.expect.element(elementSelector).to.have.value.that.equals(expectedValue);
}

/*
* assert page title
*/
var assertPageTitle = function(page, elementSelector) {
  return page.assert.title(elementSelector);
};

/*
* scroll to element
*/
var scrollToElement =  function(page, elementSelector) {
  waitElementVisible(page, elementSelector);
  return page.moveToElement(elementSelector, 0,0)
};

/*
* sleep/pause page (this.api)
*/
var pauseSleep = function(page, timeSleep) {
  return page.pause(timeSleep);
};

/*
* expect to be visible
*/
var expectVisible = function(page,elementSelector) {
  waitElementVisible(page, elementSelector);
  return page.expect.element(elementSelector).to.be.visible;
};

/*
* expect to not be visible
*/
var expectNotVisible = function(page,elementSelector) {
  return page.expect.element(elementSelector).to.not.be.visible;
};

/*
* expect to be not present
*/
var expectNotFound = function(page,elementSelector) {
  return page.expect.element(elementSelector).not.to.be.present;
};

/*
* expect to be enabled
*/
const expectEnabled = function (page,elementSelector){
  return page.expect.element(elementSelector).to.be.enabled;
}

/*
* expect to be not enabled
*/
const expectNotEnabled = function (page,elementSelector){
  return page.expect.element(elementSelector).to.not.be.enabled;
}

/*
* expect to be present
*/
var expectPresent = function(page,elementSelector) {
  waitElementPresent(page, elementSelector);
  return page.expect.element(elementSelector).to.be.present;
};

/*
* choose an option from dropdown list
*/
var chooseOptionValue = function(page,elementSelector,selectedOption){
  waitElementVisible(page, elementSelector);
  return page.click(elementSelector,()=>{
    if(selectedOption==""){
      page.click(elementSelector + ">option[value]");
    } 
    else{
      waitElementVisible(page, elementSelector + ">option[value='"+selectedOption+"']");
      page.click(elementSelector + ">option[value='"+selectedOption+"']");
    }
      
  })
};

/*
* choose an option from dropdown list based on its class
*/
var chooseOptionClass = function(page,elementSelector,value){
  waitElementVisible(page, elementSelector);
  return page.click(elementSelector,()=>{
    if(value==''){
      page.click(elementSelector + ">option[class]");
    }
    else{
      waitElementVisible(page, elementSelector + ">option[class='ts-option-"+value.replace(/\\|\/|\)|\(|\&|\.|,|\s/g,'').toLowerCase()+"']");
      page.click(elementSelector + ">option[class='ts-option-"+value.replace(/\\|\/|\)|\(|\&|\.|,|\s/g,'').toLowerCase()+"']");
    }
  })
};

/*
* expect if element is selected
*/
var expectElementSelected = function(page,elementSelector) {
  waitElementVisible(page, elementSelector);
  return page.expect.element(elementSelector).to.be.selected;
};

/*
* get text from one element then assert to other element
*/
var getElementTextAssert = function(page, elementSelector, elementToAssert) {
  waitElementVisible(page, elementSelector);
  return page.getText(elementSelector, function(result){
    return page.expect.element(elementToAssert).text.to.equal(result.value);
  })
};

/* 
* Search text from the given element
*/
var searchTextByElements = function (client, elementSelector, expectedText) {
  var totalFound = false;
  
  pauseSleep (client, 5000);
  waitElementVisible(client, elementSelector);
  client.elements('css selector', elementSelector, function (resultValues) {  
    for (var key in resultValues.value) {
      client.elementIdText(resultValues.value[key].ELEMENT, function (res) {
        if (res.value.indexOf(expectedText) > -1 ) {
          totalFound = true;
        }
      });
    }
  });
  return client.perform(function() {
    if (totalFound==true) client.assert.visible(elementSelector, 'FOUND');
    else client.assert.visible('not_found', 'NOT FOUND');
  });
};

/* 
* Assertion ascending of the sorting in table, given colomn/elementSelector should has text
*/
var assertElementSortedAsc = function (client, sortedBy, elementSelector, cmpType) {
  var totalFound = true, k = 0, newData;
  var name = new Array();

  pauseSleep (client, 5000);
  client.elements('css selector', elementSelector, function (resultValues) {  
    for (var key in resultValues.value) {
      client.elementIdText(resultValues.value[key].ELEMENT, function (res) {
        if (sortedBy == 'Tanggal pendaftaran') {
          newData = common.convertMonth(res.value);
        }
        else newData = res.value;
        name[k] = newData;
        k++;
      });
    }
  });
  return client.perform(function() {
    for (var index = 0; index < name.length-1; index++) {
      if (cmpType == 'STRING') {
        if (name[index].localeCompare (name[index+1]) == 1) totalFound = false;
      }
      else if (cmpType == 'INTEGER') {
        if (name[index] > name[index+1]) totalFound = false;
      }
    }
    if (totalFound) client.assert.visible(elementSelector, 'SORTED')  
    else client.assert.visible('not_found', 'NOT SORTED')
  });
};

/* 
* Assertion descending of the sorting in table, given colomn/elementSelector should has text
*/
var assertElementSortedDesc = function (client, sortedBy, elementSelector, cmpType) {
  var totalFound = true, k = 0, newData;
  var name = new Array();

  pauseSleep (client, 5000);
  client.elements('css selector', elementSelector, function (resultValues) {  
    for (var key in resultValues.value) {
      client.elementIdText(resultValues.value[key].ELEMENT, function (res) {
        if (sortedBy == 'Tanggal pendaftaran') {
          newData = common.convertMonth(res.value);
        }
        else newData = res.value;
        name[k] = newData;
        k++;
      });
    }
  });
  return client.perform(function() {
    for (var index = 0; index < name.length-1; index++) {
      if (cmpType == 'STRING') {
        if (name[index].localeCompare (name[index+1]) == -1) totalFound = false;
      }
      else if (cmpType == 'INTEGER') {
        if (name[index] < name[index+1]) totalFound = false;
      }
    }
    if (totalFound) client.assert.visible(elementSelector, 'SORTED')  
    else client.assert.visible('not_found', 'NOT SORTED')
  });
};

/* 
* Assertion of the filter in table, given colomn/elementSelector should has text
*/
var assertElementFilter = function (client, elementSelector, filterBy) {
  var totalFound = true;
  
  pauseSleep (client, 5000);
  waitElementVisible(client, elementSelector);
  client.elements('css selector', elementSelector, function (resultValues) {  
    for (var key in resultValues.value) {
      client.elementIdText(resultValues.value[key].ELEMENT, function (res) {
        if (res.value != filterBy ) {
          totalFound = false;
        }
      });
    }
  });
  return client.perform(function() {
    if (totalFound==true) client.assert.visible(elementSelector, 'FOUND');
    else client.assert.visible('not_found', 'NOT FOUND');
  });
};

/* 
* Assertion of one table to the next table
* elementSelector: element, elementSelectorNext: element for next button, 
* elementPagination: element for paging information (1 dari 1 halaman), dataPagination: text of elementPagination
*/
var assertElementPagination = function (client, elementSelector, elementSelectorNext, elementPagination, dataPagination) {
  var totalFound = true, wordNotFound = true, i = 0, j = 0, newData;
  var name1 = new Array(), name2 = new Array();
  
  waitElementVisible(client, elementSelector);
  client.elements('css selector', elementPagination, function (resultValues) {  
    for (var key in resultValues.value) {
      client.elementIdText(resultValues.value[key].ELEMENT, function (res) {
        if (dataPagination == res.value) {
          wordNotFound = false;
        }
        else {
          pauseSleep (client, 5000);
          client.elements('css selector', elementSelector, function (resultValues1) {  
            for (var key in resultValues1.value) {
              client.elementIdText(resultValues1.value[key].ELEMENT, function (res1) {
                name1[i] = res1.value;
                i++;
              });
            }
          });
          clickElement (client, elementSelectorNext);
          pauseSleep (client, 5000);
          client.elements('css selector', elementSelector, function (resultValues2) {  
            for (var key in resultValues2.value) {
              client.elementIdText(resultValues2.value[key].ELEMENT, function (res2) {
                name2[j] = res2.value;
                j++;
              });
            }
          });
        }
      });
    }
  });
  return client.perform(function() {
    if (wordNotFound) {
      for (var index = 0; index < name1.length; index++) {
        if (name1[index] ==  name2[index]) totalFound = false;
      }
    }
    if (totalFound) client.assert.visible(elementSelector, 'Pagination')  
    else client.assert.visible('not_found', 'Pagination NOT Worked')
  });
};

/* 
* Click the given element by element's text
* elementSelector: element, dataElement: text of element
*/
var clickElementByText = function (client, elementSelector, dataElement) {
  var wordFound = false;

  //waitElementVisible(client, elementSelector);
  client.elements('css selector', elementSelector, function (resultValues) {  
    for (let key = 0; key < resultValues.value.length; key++) {
      if (wordFound === true) {
        break;
      }
      else {
        client.elementIdText(resultValues.value[key].ELEMENT, function (res) {
          if (dataElement == res.value) {
            client.elementIdClick (resultValues.value[key].ELEMENT);
            wordFound = true;
          }
        });
      }
    }
  });

  return client.perform(function() {
    if (wordFound) client.assert.visible('body', 'Element FOUND');  
    else client.assert.visible('not_found', 'Element NOT FOUND');
  });
};

/* 
* Click the given element by element's attribute name
* elementSelector: element, className: class of element, dataElement: attribute name
*/
var clickElementByIdAtr = function (client, elementSelector, className, dataElement) {
  var wordFound = false;

  //waitElementVisible(client, elementSelector);
  client.elements('css selector', elementSelector, function (resultValues) {  
    for (let key = 0; key < resultValues.value.length; key++) {
      if (wordFound === true) {
        break;
      }
      else {
        client.elementIdAttribute (resultValues.value[key].ELEMENT, className, function (res) {
          if (dataElement == res.value) {
            client.elementIdClick (resultValues.value[key].ELEMENT);
            wordFound = true;
          }
        });
      }
    }
  });

  return client.perform(function() {
    if (wordFound) client.assert.visible('body', 'Element FOUND');  
    else client.assert.visible('not_found', 'Element NOT FOUND');
  });
};

/* 
* Set value the given element by element's attribute name
* elementSelector: element, className: class of element, dataElement: attribute name, value: data to be input
*/
var setElementByIdAtr = function (client, elementSelector, className, dataElement, value) {
  var wordFound = false;

  //waitElementVisible(client, elementSelector);
  client.elements('css selector', elementSelector, function (resultValues) {  
    var arr = new Array();
    for (let key = 0; key < resultValues.value.length; key++) {
      if (wordFound === true) {
        break;
      }
      else {
        client.elementIdAttribute (resultValues.value[key].ELEMENT, className, function (res) {
          if (dataElement == res.value) {
            client.elementIdClear (resultValues.value[key].ELEMENT);
            arr[0] = value;
            client.elementIdValue (resultValues.value[key].ELEMENT, arr[0]);
            wordFound = true;
          }
        });
      }
    }
  });

  return client.perform(function() {
    if (wordFound) client.assert.visible('body', 'Element FOUND');  
    else client.assert.visible('not_found', 'Element NOT FOUND');
  });
};

/*
* checks if the given element does not exist in the DOM
*/
var assertElementNotPresent = function (page, elementSelector) {
  page.waitForElementNotVisible(elementSelector, 3000);
};

/* 
* create folder under /helper and put file to be upload
* example: elementSelector = .addImageButtonLarge>input[type="file"]
* pathFile = '/home/seluser/upload/1.jpg'
*/
var uploadFile = function (page, elementSelector, pathFile) {
  
  page.execute(function(data){
    document.querySelector(elementSelector).className="";
  }, [], function(result){
  console.log(result);
  });
  
  console.log(require('path').resolve(pathFile))
  return page.setValue(elementSelector, require('path').resolve(pathFile), function(result) {
    if(result.status !== 0){
      console.log(result);
    }
  });
};

/*
* set value to element using keyboard press
*/
var keyboardPress = function(page, elementSelector, words) {
  clickElement(page, elementSelector);
  typedWords = Array.from(words);
  return typedWords.forEach(function(value){
    return page.keys(value);
  });
};

/*
* set value to element using keyboard press with delay
*/
var keyboardPresswithDelay = function(page, elementSelector, words) {
  clickElement(page, elementSelector);
  typedWords = Array.from(words);
  return typedWords.forEach(function(value){
    pauseSleep(page, 500)
    return page.keys(value);
  });
};

/*
* wait element enabled until timeout
*/
var waitUntilElemenEnabled = function(page, elementSelector){
  waitElementPresent(page, elementSelector);
  page.waitForElementVisible(elementSelector+':enabled', 30000);
}

/*
* wait element disabled until timeout
*/
let waitUntilElemenDisabled = function(page, elementSelector){
  waitElementPresent(page, elementSelector);
  page.waitForElementVisible(elementSelector+':disabled', 30000);
}

/*
* switch tab window
* info : if selectedTab not define or blank go to current tab
* if selectedTab define (integer) go to number tab that is input
*/
let switchTabWindow = function (page, selectedTab) {
    page.window_handles(function (result) {
      if (selectedTab === '' || selectedTab === undefined) {
            page.switchWindow(result.value[result.value.length-1]);
      } else if (selectedTab > result.value.length) { 
        console.log('tab number not found')
      } else {
        page.switchWindow(result.value[selectedTab - 1]);
      }
    });
}
  
module.exports = {
  setURL: setURL,
  clickElement: clickElement,
  waitElementPresent: waitElementPresent,
  waitElementVisible: waitElementVisible,
  setValueElement: setValueElement,
  getStringText: getStringText,
  assertPageTitle: assertPageTitle,
  pauseSleep: pauseSleep,
  scrollToElement: scrollToElement,
  setValueElementThenEnter: setValueElementThenEnter,
  expectVisible: expectVisible,
  expectNotFound: expectNotFound,
  expectPresent: expectPresent,
  chooseOptionValue: chooseOptionValue,
  assertContainsText: assertContainsText,
  expectElementSelected: expectElementSelected,
  expectEqualsTextFromElement: expectEqualsTextFromElement,
  getElementTextAssert: getElementTextAssert,
  searchTextByElements: searchTextByElements,
  assertElementSortedAsc: assertElementSortedAsc,
  assertElementSortedDesc: assertElementSortedDesc,
  assertElementFilter: assertElementFilter,
  assertElementPagination: assertElementPagination,
  clickElementByText: clickElementByText,
  clickElementByIdAtr: clickElementByIdAtr,
  setElementByIdAtr: setElementByIdAtr,
  assertElementNotPresent: assertElementNotPresent,
  uploadFile: uploadFile,
  keyboardPress: keyboardPress,
  keyboardPresswithDelay: keyboardPresswithDelay,
  expectEqualsValueFromElement: expectEqualsValueFromElement,
  expectNotVisible: expectNotVisible,
  chooseOptionClass: chooseOptionClass,
  expectEnabled: expectEnabled,
  expectNotEnabled: expectNotEnabled,
  waitUntilElemenEnabled: waitUntilElemenEnabled,
  waitUntilElemenDisabled,
  switchTabWindow,
  maxWindow
}
  